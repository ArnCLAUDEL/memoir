\section{Quality}\label{sec:quality}
We've talked about Software Craftsmanship and Extreme Programming,
one is a culture, the other is a methodology but both focus on Quality.
\\
This chapter will first present the metrics given by the analysis
tool Sonar and how we can use it during the refactoring phase.
Then we'll present a bunch of principles and design rules that
are used to improve the code quality and ease the maintenance.

\subsection{Sonar}\label{subsec:sonar}
%https://docs.sonarqube.org/latest/user-guide/issues/
%https://docs.sonarqube.org/latest/user-guide/concepts/
Sonar is a static code analysis tool, this means that it inspects
directly the source code and try to find some potential bugs, security
holes, duplicated code and code smells.
It is based on a huge repository of rules and common good practices.
Each rule comes with a description and good/bad examples. \\
After the analysis, Sonar gives a global grade (A, B, C etc.) and
publishes a detailed report with every broken rules.
In a CI platform, sonar analysis must be performed for every commit and
developers must keep an eye on the report. \\
\newline
Any broken rule during the analysis will create an issue in the report.
There are three types of issues :

\begin{description}
    \item[Bug :]
    An issue that represents something wrong in the code.
    If this has not broken yet, it will, and probably at the worst
    possible moment.
    This needs to be fixed.
    Yesterday.
    \item[Vulnerabilty :]
    A security-related issue which represents a backdoor for attackers.
    \item[Code Smell :]
    A maintainability-related issue in the code.
    Leaving it as-is means that at best maintainers will have a harder
    time than they should making changes to the code.
    At worst, they'll be so confused by the state of the code that
    they'll introduce additional errors as they make changes.
\end{description}

There are 5 levels of severity :

\begin{description}
    \item[BLOCKER :]
Bug with a high probability to impact the behavior of the application
in production: memory leak, unclosed JDBC connection, ....
The code MUST be immediately fixed.
    \item[CRITICAL :]
Either a bug with a low probability to impact the behavior of the
application in production or an issue which represents a
security flaw: empty catch block, SQL injection, \ldots
The code MUST be immediately reviewed.
    \item[MAJOR :]
Quality flaw which can highly impact the developer productivity:
uncovered piece of code, duplicated blocks, unused parameters,
    \ldots
    \item[MINOR :]
Quality flaw which can slightly impact the developer productivity:
lines should not be too long, "switch" statements should have at
least 3 cases, \ldots
    \item[INFO :]
Neither a bug nor a quality flaw, just a finding.
\end{description}

We are not going to detail deeply Sonar rules, there're too many of them,
this is actually why Sonar exists.
Programmers are humans and they can easily leave an unused variable, an
opened resource, forget to check for a likely null value or add an if
statement with a condition that is always false. \\
Sonar is a great companion that integrates perfectly with IDEs and will
necessarily teach something new to anyone using it.

\subsection{Principles and Design}\label{subsec:principles}

\subsubsection{Design Patterns}
%https://en.wikipedia.org/wiki/Design_pattern
Design Patterns is a book written by Erich Gamma,
Richard Helm, Ralph Johnson and John Vlissides, also known as the
Gang of Four. \\

\begin{quotation}
    The elements of this language are entities called patterns.
    Each pattern describes a problem that occurs over and over again
    in our environment, and then describes the core of the solution to
    that problem, in such a way that you can use this solution a million
    times over, without ever doing it the same way twice.
    \textemdash Christopher Alexander
\end{quotation}

The book introduces over 23 Design Patterns that help in solving common
problem that programmers encounter.
There is a nice diagram that present them all.
%https://infinitescript.com/wordpress/wp-content/uploads/
%2014/10/Design-Pattern-Relationships.jpg
\\
\newline
We're not going to detail each pattern, we'll only take a look at some
interesting ones, that we'll use or mention later.\\
\newline
Singleton pattern is a very simple but useful one.
The idea with singleton is to only have one instance of an object in the
entire application.


\subsubsection{SOLID}
SOLID

\subsubsection{KISS}
Keep It Simple Stupid is a \textit{simple} principle that encourages to
always try the simplest approach to solve a problem. \\
\newline
It's very easy to over engineer a solution to a problem, because we want
to cover all the possible cases or we want to add some extra
features that may be useful later.
This over engineering badly affects the maintainability of the code base
because the feature is overwhelmed by an unnecessary complex code. \\
\newline
KISS principle is often used in TDD because each step is a small
problem that solves a bigger complex problem.
In the Red, Green, Refactor cycle, during the Red phase, we must write
the simplest code to pass the test, this is exactly what KISS is about.
\\
\newline
One could argue that the simplest solution is not always the best one.
Sometimes it's nice to add some extra code to handle failure cases, add
defensive code for method parameters etc. \\
It depends on the context, for example a small private method, can make
legit assumptions and could omit to check null values when using
local field.
However a public method inherited from an interface should check for the
correctness of the received parameters.

\subsubsection{DRY}
Don't Repeat Yourself is a principle against code duplication and in
favour of reusable items in general. \\
\newline
Duplicated values and logic mean O(n) complexity when a change is needed
instead of O(1), if it was written in a single place.
Maintenance then becomes a nightmare and in the worst case, some lines of
code are omitted when refactoring, leading to inconsistent logic in the
application. \\
\newline
This principle is therefore vital for business logic but also relevant
for technical and utility features.
There're plenty of libraries that implements common algorithms, file
manipulation, serialization etc.
So it's usually a bad idea to try to reimplement locally something that
have been better done and is used by the whole community. \\
\newline
DRY is also a global principle and can be applied at a much higher level.
More and more production-ready frameworks or services only requires
the business code and can be immediately deployed.
Companies also try to reduce the time to market by creating starter kit,
reusing CI platform and cloud providers.

\subsubsection{Behaviour Parametrization}
Behaviour Parametrization is included in the DRY principle and is very
common in Functional Programming. \\
\newline
In traditional code, if we want to filter elements of a list of String
for example, we would write a for loop and write our condition inside.
Every element that matches the condition are then added to a previously
created list. \\
This works perfectly, but if tomorrow we want to add the same feature,
but with a slightly different condition.
We must rewrite the for loop, recreate a list and filter our elements.
We've just written Boilerplate code, that is duplicated lines of code
that are almost identical. \\
\newline
Behaviour Parametrization exactly solves that problem by externalizing
the behaviour (in our example, the filter condition) and reusing the
common code (the for loop and list creation). \\
There are well known Collection's methods such as map, filter or reduce
that takes behaviour as parameter.
Some cloud providers also provides ready-to-use web services,
where you simply add your business code and it's automatically managed
and deployed.

\subsubsection{Clean Code}
Clean Code is a subset of rules and principles that helps to make and
keep a clean codebase and we are going to list the main ideas. \\
\newline
A Clean code is literally \textit{clean}, it should be
pleasant to read and it's easy to understand what's going on.
This is where DRY and KISS principles, that we mentioned earlier,
are very important to have a cleaner code.
Class, method and variable names should be meaningful and self
describing, so there's no need of extra comment to explain the logic.
The code across the project always follows the same standards, has the
same format and is well indented. \\
\newline
Nested blocks (for/if/else \ldots) shouldn't go to deep
because the deeper, the harder it is to understand the logic.
For example, error handling code (usually try/catch blocks) should be
externalized and located in a dedicated method.
This reduces the pollution and the noise around the main feature. \\
There is an interesting metric called Cyclomatic Complexity that tries to
measure the level of visual complexity of code.
Nested statements, as well as switch statements, are one of the worst
elements and add a lot of complexity.
Usually, when there are several nested lines of code, it is better to
extract them to a private method.

\subsubsection{Magic Numbers}
Magic Numbers represent all the hardcoded values in the code that have
a real meaning and logic. \\
\newline
These values are likely to change in the future and probably need an
explanation or a comment to understand what they really are.
The code is less readable because its intent is not clear and the
maintenance becomes harder because every location where the value
is hardcoded must be modified. \\
A good practice is first to extract these values to variables or
constants and, if the value is very dynamic, externalize the
parameterization in a config file so it's easier to change.

\subsubsection{Side Effect}
A Side Effect occurs during an operation and modifies (possibly silently)
the state of the system. \\
Functional Programming style tends to avoid having side effects in order
to make a Pure functional program.
A pure function can be compared to a mathematics function, the same
input always returns the same output.
There isn't a function that could affect another one or return a
different value when you call it 5 times in a row. \\
\newline
For example, the method \textit{close} of an OutputStream has side
effects, because it closes the underlying resource and any further
write will fail.
This is the intended behaviour, however this affects the entire system
because if there are other components that uses this OutputStream, this
operation will prevent them from writing again. \\
Side effects therefore can be dangerous when they have an impact on
several components in the system, that are probably not even aware of
that and concurrency becomes harder to manage. \\
\newline
Side effects are also not always visible and may not directly change the
result of an operation.
We mentioned the method \textit{close} of an OutputStream earlier, but
what happens if we never call this method.
We would simply leave an unclosed resource after the process, but the
result is correct and it's completely transparent to the caller.
However, if the process is repeated a thousand of times, there will be
a thousand of unclosed streams, which leads to memory leaks and the
system would potentially run out of memory. \\
\newline
There are a lot of examples that shows the consequences of having
to much side effects, we'll not cover them all.
The idea was simply to show that a side effect may change the result
after multiple executions of an operation or can be completely
transparent but still affect the entire system.

\subsubsection{Immutability}
Immutability is closely related to Side Effects and consists in set-once
values, that never change over time. \\
It's, again, very frequent in Functional Programming style, because
it's very helpful when we want to reduce side effects.
An immutable value is set once and therefore is read-only after its
initialization. \\
\newline
One advantage of immutable value is that you can expose and share
it without having to worry about the potential side effects.
This is very handy when you want to pass an object to a third party
library, that is a code you don't have control of.
If the list is mutable, then the library could silently remove some
elements while returning the intended result.
If the passed list is immutable, then you don't take risk of having your
list modified. \\
\newline
Concurrency on immutable values is therefore not a problem anymore.
There is no need of costly locks and synchronization mechanisms, because
we now guarantee that the value won't change, so everyone can access it
at the same time. \\
\newline
Performances can also be improved when using immutable values.
If a variable is set once and read only, there is no need to check if
its value has changed.
This means that when there is a reference to the variable, instead of
having a look up to get the current value in the memory, the initial
value can directly be used.
This a common optimization technique used by compilers and runtime
environments. \\
\newline
Immutability also clarifies the intent of the code.
When a field is immutable, then it's because it shouldn't be modified.
However, if there is a setter, even if the field should not change,
you let the possibility to do it and it's likely to be wrongly used. \\
\newline
Immutability is therefore a great tool to reduce side effects, improve
performances, simplify concurrency and clarify intents.

\subsubsection{Value Objects}
Value Objects are interchangeable objects that don't have an identity.
They are part of the Domain Driven Design methodology, but we won't
detail DDD in this memoir, so we only mention it. \\
\newline
A value object only holds a value and doesn't have any business logic
or do complex operations.
Frequent usage are for currency, date, coordinates, etc.
Only their field values matter so \textit{equals} and \textit{Hashcode}
implementations should therefore only use the field values and return
a coherent result.
That is, if two objects are instantiated with the same values, they're
equal and have the same hashcode. \\
\newline
Value Objects should be immutable, easy and cheap to create, this is why
Factory and Singleton design patterns work great with them.
Factory allows us to ease and control the instantiation of our objects
and Singleton could be used in case of performances issues.
As Value Objects are frequently instantiated, sometimes you could have
a lot of small objects although they're all the same and interchangeable.
A Singleton cache could therefore be inserted inside the Factory and
reuse the same Value Object. \\
\newline
There are a lot of frameworks and libraries that provide easy
implementations of Value Object, using annotations or abstract classes.
They reduce the boilerplate code and let us have a very concise code,
with only the field declaration. \\
Usually they provide an interesting technique, named Withers, used to
modify a Value Object.
We said that a Value Object should be immutable, this is still the case,
however we would like to be able to easily modify it, and avoid having
to instantiate another new object when we only want to modify one field.
Withers is like Getters and Setters, it's a convention of methods that
behave like Setters, but instead of modifying the current object,
they return a new object with the same attributes and the modified
value. \\
It's a very Functional Style, with no side effect, that always returns
a new copy instead of modifying the current object.

\subsubsection{Fail Fast}
Fail Fast principle prevents the application from continuing a process if
it's likely to fail in the next steps. \\
\newline
This principle is usually implemented using a defensive code, that checks
the method parameters and ensure that every value, variable, service etc.
are available and consistent before continuing the process.
If some method parameters or fields are null for example, then any
further method call will necessarily fail. \\
\newline
At first glance, it doesn't matter if it fails now or later, in the end
it will always fail no matter what.
However the process may have several side effect operations and the null
parameter may be used only between two operations. \\
This means that the first operation is made even tough we already know
that we cannot reach the second operation, because the code will fail
with a null pointer exception.
If rollbacks are not correctly handled, then the application enters into
an inconsistent state and things get much worse. \\
\newline
Beside this inconsistency, this principle is also very helpful during
the development phase, because instead of hiding potential bugs, it
immediately notifies the programmer that something looks wrong. \\
One could argue that the robustness of the application is getting
weaker, especially on the client side, where the application may crash
if unexpected failures are not well handled.
Extensive use of this principle must be used with caution and
appropriated controls and failure handling must be added.

\subsubsection{Null Pointers}
%https://martinfowler.com/eaaCatalog/specialCase.html
%https://medium.com/@hinchman_amanda/null-pointer-references-the
%-billion-dollar-mistake-1e616534d485
%https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained
Sir C. A. R. Hoare, the null pointer creator, said the following.
\begin{quotation}
    I call it my billion-dollar mistake.
\end{quotation}
Null pointer is one of the most painful features in Object Oriented
Programming.
Missing value, business case not handled, unlikely state \ldots There are
a lot situations where we don't really know what to do or return.
The easy solution is therefore to return null and see what happens. \\
We talked about the Fail Fast principle earlier, usually applications
that use null values don't fail fast, otherwise they would either
stop using null or stop failing fast. \\
Obviously the first solution is better and we are going to present some
alternatives to null and some situations where null is viable. \\
\newline
The distinction between, a missing value because of the
programmer's mistake, and a real missing value because of business logic,
must be clear and unambiguous. \\
Null pointers are completely ambiguous because there's no guarantee that
the returned null pointer is actually representing a real missing value.
Maybe the programmer forgot to fill a particular field of an object
or used the wrong key when querying a HashMap or even have not
implemented this case and is returning null by default.
\\
\newline
Optional is a common type across programming languages and is now widely
used in standard APIs.
An Optional is a very simple object, that either contains a value or
is empty.
It has methods to tell whether it's empty or not and a getter (and some
utility methods). \\
The idea of optional is first to hide and encapsulate the null value
from the application's code.
Second, the programmer now has explicitly said that the method may not
return a result.
Where before the programmer could forget to think of checking for null
value, he is now aware that the returned value can be missing.
He is probably going to look why in the documentation and eventually
will implement a special case to handle it.
In addition, if a null pointer is returned, then there's no doubt that
it's a mistake. \\
Unfortunately sometimes, we can't really represent an optional value
with the Optional type.
For example in databases, it's frequent to have null pointers because
it occupies less disk space and it's faster. \\
It's also okay to use null in small private local context, to keep a
simpler code.\\
\newline
Another alternative is to use the Null Object Pattern.
This pattern uses a real object or value to represent a special or
missing value. \\
For example, an object Task could have the states PENDING, STARTED
and FINISHED .
When the task is submitted to the executor, the state is PENDING,
when the executor actually executes it, it turns to STARTED and when
it's done, it's FINISHED. \\
But when we create the Task, there is no current state, so we could use
null to represent the missing state.
Or we could introduce a new state, that indicates that there is currently
no state, NONE. \\
Now, when we want to see the current state of the task, we are
manipulating real values instead of a set of values and null pointers. \\
We also know that if the state is null, then it's because there was
a problem during the initialization of the Task. \\
Sometimes, it's hard to define a value for every possible case.
Dates are a nice example, it would be awkward to replace a missing date
by default value. \\
\newline
These two techniques are very helpful and tends to improve both the
readability and the design of the code.
The code is self describing and now manipulates as much as possible
real values instead of ambiguous null pointer.

\subsubsection{CQS}
%https://martinfowler.com/bliki/CommandQuerySeparation.html
%https://martinfowler.com/bliki/ObservableState.html
Command and Query Separation tries to separate operations that have
side effects and the ones that don't. \\
\newline
A Command is a method that only changes the state of the system and
returns void.
Not returning a value necessarily means that the method is doing
something elsewhere and therefore have side effects.
Further queries will be affected by this command call and their results
may vary.
This clarifies the intent of the method and its impact on the
application's state. \\
\newline
A Query is a method that returns a value and don't modify the
Observable State of the object.
This means that a query call will never affect or change the result of
the next queries on the same object, this is why we use the term of
Observable State.
Sometimes there are internal states that can be modified by queries but
they won't change the result of future queries.
One example is lazy loading, the first query call will have a side effect
but won't actually impact the returned value. \\
\newline
Pure CQS implementation is not very common and sometimes hard to achieve.
For example, we want to persist a JPA Entity that has auto generated ID.
When we call the persist method, we may need to return the persisted
object to retrieve the generated ID.
There are a lot of situations where it's more handy to directly return a
value after executing a command, this is why a full CQS application is
not necessarily ideal. \\
However, it's a nice principle to have in mind, because it helps to
identifies what really changes the application's state and what is only
retrieving information from it.
Having less side effects in the code code is usually a great choice.
