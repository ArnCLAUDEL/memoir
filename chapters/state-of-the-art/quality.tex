\section{Quality}\label{sec:quality}
We've talked about Software Craftsmanship and Extreme Programming,
one is a culture, the other is a methodology but both focus on Quality.
\\
This chapter will first present the metrics given by the analysis
tool Sonar and how we can use it during the refactoring phase.
Then we'll present a bunch of principles and design rules that
are used to improve the code quality and ease the maintenance.

\subsection{Sonar}\label{subsec:sonar}
%https://docs.sonarqube.org/latest/user-guide/issues/
%https://docs.sonarqube.org/latest/user-guide/concepts/
Sonar is a static code analysis tool, this means that it inspects
directly the source code and try to find some potential bugs, security
holes, duplicated code and code smells.
It is based on a huge repository of rules and common good practices.
Each rule comes with a description and good/bad examples. \\
After the analysis, Sonar gives a global grade (A, B, C etc.) and
publishes a detailed report with every broken rules.
In a CI platform, sonar analysis must be performed for every commit and
developers must keep an eye on the report. \\
\newline
Any broken rule during the analysis will create an issue in the report.
There are three types of issues :

\begin{description}
    \item[Bug :]
    An issue that represents something wrong in the code.
    If this has not broken yet, it will, and probably at the worst
    possible moment.
    This needs to be fixed.
    Yesterday.
    \item[Vulnerabilty :]
    A security-related issue which represents a backdoor for attackers.
    \item[Code Smell :]
    A maintainability-related issue in the code.
    Leaving it as-is means that at best maintainers will have a harder
    time than they should making changes to the code.
    At worst, they'll be so confused by the state of the code that
    they'll introduce additional errors as they make changes.
\end{description}

There are 5 levels of severity :

\begin{description}
    \item[BLOCKER :]
Bug with a high probability to impact the behavior of the application
in production: memory leak, unclosed JDBC connection, ....
The code MUST be immediately fixed.
    \item[CRITICAL :]
Either a bug with a low probability to impact the behavior of the
application in production or an issue which represents a
security flaw: empty catch block, SQL injection, \ldots
The code MUST be immediately reviewed.
    \item[MAJOR :]
Quality flaw which can highly impact the developer productivity:
uncovered piece of code, duplicated blocks, unused parameters,
    \ldots
    \item[MINOR :]
Quality flaw which can slightly impact the developer productivity:
lines should not be too long, "switch" statements should have at
least 3 cases, \ldots
    \item[INFO :]
Neither a bug nor a quality flaw, just a finding.
\end{description}

We are not going to detail deeply Sonar rules, there're too many of them,
this is actually why Sonar exists.
Programmers are humans and they can easily leave an unused variable, an
opened resource, forget to check for a likely null value or add an if
statement with a condition that is always false. \\
Sonar is a great companion that integrates perfectly with IDEs and will
necessarily teach something new to anyone using it.

\subsection{Principles and Design}\label{subsec:principles}

\subsubsection{Design Patterns}
Design Patterns

\subsubsection{SOLID}
SOLID

\subsubsection{Clean Code}
Clean Code

\subsubsection{KISS}
Keep It Simple Stupid is a \textit{simple} principle that encourages to
always try the simplest approach to solve a problem.
It's very easy to over engineer a solution to a problem, because we want
to cover all the possible cases or we want to add some extra
features that may be useful later.
This over engineering badly affects the maintainability of the code base
because the feature is overwhelmed by an unnecessary complex code. \\
\newline
KISS principle is often used in TDD because each step is a small
problem that solves a bigger complex problem.
In the Red, Green, Refactor cycle, during the Red phase, we must write
the simplest code to pass the test, this is exactly what KISS is about.
\\
\newline
One could argue that the simplest solution is not always the best one.
Sometimes it's nice to add some extra code to handle failure cases, add
defensive code for method parameters etc. \\
It depends on the context, for example a small private method, can make
legit assumptions and could omit to check null values when using
local field.
However a public method inherited from an interface should check for the
correctness of the received parameters.

\subsubsection{DRY}
Don't Repeat Yourself is a principle against code duplication and in
favour of reusable code. \\
Duplicated values and logic mean O(n) complexity when a change is needed
instead of O(1).
Maintenance becomes then a nightmare and in the worst case some lines of
code are omitted when refactoring, leading to inconsistent logic in the
application. \\
\newline
This principle is therefore vital for business logic but also relevant
for technical and utility features.
There're plenty of libraries that implements common algorithms, file
manipulation, parsing etc.
So it's usually a bad idea to try to reimplement locally something that
have been better done and used by the whole community. \\
\newline
DRY is also a global principle and can be applied at a much higher level.
More and more production-ready frameworks or services only requires
the business code and can be immediately deployed.
Companies also try to reduce the time to market by creating starter kit,
reusing CI platform and cloud providers.

\subsubsection{Behaviour Parametrization}
Behaviour Parametrization

\subsubsection{YAGNI}
YAGNI

\subsubsection{Magic Numbers}
Magic Numbers

\subsubsection{Value Objects}
Value Objects

\subsubsection{Null Object Pattern}
Null Object Pattern

\subsubsection{Fail Fast}
Fail Fast

\subsubsection{Side Effect}
Side Effect

\subsubsection{Immutability}
Immutability

\subsubsection{CQS}
CQS
