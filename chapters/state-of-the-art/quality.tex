\section{Quality}\label{sec:quality}
We've talked about Software Craftsmanship and Extreme Programming,
one is a culture, the other is a methodology but both focus on Quality.
\\
This chapter will first present the metrics given by the analysis
tool Sonar and how we can use it during the refactoring phase.
Then we'll present a bunch of principles and design rules that
are used to improve the code quality and ease the maintenance.

\subsection{Sonar}\label{subsec:sonar}
%https://docs.sonarqube.org/latest/user-guide/issues/
%https://docs.sonarqube.org/latest/user-guide/concepts/
Sonar is a static code analysis tool, this means that it inspects
directly the source code and try to find some potential bugs, security
holes, duplicated code and code smells.
It is based on a huge repository of rules and common good practices.
Each rule comes with a description and good/bad examples. \\
After the analysis, Sonar gives a global grade (A, B, C etc.) and
publishes a detailed report with every broken rules.
In a CI platform, sonar analysis must be performed for every commit and
developers must keep an eye on the report. \\
\newline
Any broken rule during the analysis will create an issue in the report.
There are three types of issues :

\begin{description}
    \item[Bug :]
    An issue that represents something wrong in the code.
    If this has not broken yet, it will, and probably at the worst
    possible moment.
    This needs to be fixed.
    Yesterday.
    \item[Vulnerabilty :]
    A security-related issue which represents a backdoor for attackers.
    \item[Code Smell :]
    A maintainability-related issue in the code.
    Leaving it as-is means that at best maintainers will have a harder
    time than they should making changes to the code.
    At worst, they'll be so confused by the state of the code that
    they'll introduce additional errors as they make changes.
\end{description}

There are 5 levels of severity :

\begin{description}
    \item[BLOCKER :]
Bug with a high probability to impact the behavior of the application
in production: memory leak, unclosed JDBC connection, ....
The code MUST be immediately fixed.
    \item[CRITICAL :]
Either a bug with a low probability to impact the behavior of the
application in production or an issue which represents a
security flaw: empty catch block, SQL injection, \ldots
The code MUST be immediately reviewed.
    \item[MAJOR :]
Quality flaw which can highly impact the developer productivity:
uncovered piece of code, duplicated blocks, unused parameters,
    \ldots
    \item[MINOR :]
Quality flaw which can slightly impact the developer productivity:
lines should not be too long, "switch" statements should have at
least 3 cases, \ldots
    \item[INFO :]
Neither a bug nor a quality flaw, just a finding.
\end{description}

We are not going to detail deeply Sonar rules, there're too many of them,
this is actually why Sonar exists.
Programmers are humans and they can easily leave an unused variable, an
opened resource, forget to check for a likely null value or add an if
statement with a condition that is always false. \\
Sonar is a great companion that integrates perfectly with IDEs and will
necessarily teach something new to anyone using it.

\subsection{Principles and Design}\label{subsec:principles}

\subsubsection{Design Patterns}
Design Patterns

\subsubsection{SOLID}
SOLID

\subsubsection{KISS}
Keep It Simple Stupid is a \textit{simple} principle that encourages to
always try the simplest approach to solve a problem. \\
\newline
It's very easy to over engineer a solution to a problem, because we want
to cover all the possible cases or we want to add some extra
features that may be useful later.
This over engineering badly affects the maintainability of the code base
because the feature is overwhelmed by an unnecessary complex code. \\
\newline
KISS principle is often used in TDD because each step is a small
problem that solves a bigger complex problem.
In the Red, Green, Refactor cycle, during the Red phase, we must write
the simplest code to pass the test, this is exactly what KISS is about.
\\
\newline
One could argue that the simplest solution is not always the best one.
Sometimes it's nice to add some extra code to handle failure cases, add
defensive code for method parameters etc. \\
It depends on the context, for example a small private method, can make
legit assumptions and could omit to check null values when using
local field.
However a public method inherited from an interface should check for the
correctness of the received parameters.

\subsubsection{DRY}
Don't Repeat Yourself is a principle against code duplication and in
favour of reusable items in general. \\
\newline
Duplicated values and logic mean O(n) complexity when a change is needed
instead of O(1), if it was written in a single place.
Maintenance then becomes a nightmare and in the worst case, some lines of
code are omitted when refactoring, leading to inconsistent logic in the
application. \\
\newline
This principle is therefore vital for business logic but also relevant
for technical and utility features.
There're plenty of libraries that implements common algorithms, file
manipulation, serialization etc.
So it's usually a bad idea to try to reimplement locally something that
have been better done and is used by the whole community. \\
\newline
DRY is also a global principle and can be applied at a much higher level.
More and more production-ready frameworks or services only requires
the business code and can be immediately deployed.
Companies also try to reduce the time to market by creating starter kit,
reusing CI platform and cloud providers.

\subsubsection{Behaviour Parametrization}
Behaviour Parametrization is included in the DRY principle and is very
common in Functional Programming. \\
\newline
In traditional code, if we want to filter elements of a list of String
for example, we would write a for loop and write our condition inside.
Every element that matches the condition are then added to a previously
created list. \\
This works perfectly, but if tomorrow we want to add the same feature,
but with a slightly different condition.
We must rewrite the for loop, recreate a list and filter our elements.
We've just written Boilerplate code, that is duplicated lines of code
that are almost identical. \\
\newline
Behaviour Parametrization exactly solves that problem by externalizing
the behaviour (in our example, the filter condition) and reusing the
common code (the for loop and list creation). \\
There are well known Collection's methods such as map, filter or reduce
that takes behaviour as parameter.
Some cloud providers also provides ready-to-use web services,
where you simply add your business code and it's automatically managed
and deployed.

\subsubsection{Clean Code}
Clean Code is a subset of rules and principles that helps to make and
keep a clean codebase and we are going to list the main ideas. \\
\newline
A Clean code is literally \textit{clean}, it should be
pleasant to read and it's easy to understand what's going on.
This is where DRY and KISS principles, that we mentioned earlier,
are very important to have a cleaner code.
Class, method and variable names should be meaningful and self
describing, so there's no need of extra comment to explain the logic.
The code across the project always follows the same standards, has the
same format and is well indented. \\
\newline
Nested blocks (for/if/else \ldots) shouldn't go to deep
because the deeper, the harder it is to understand the logic.
For example, error handling code (usually try/catch blocks) should be
externalized and located in a dedicated method.
This reduces the pollution and the noise around the main feature. \\
There is an interesting metric called Cyclomatic Complexity that tries to
measure the level of visual complexity of code.
Nested statements, as well as switch statements, are one of the worst
elements and add a lot of complexity.
Usually, when there are several nested lines of code, it is better to
extract them to a private method.

\subsubsection{Magic Numbers}
Magic Numbers represent all the hardcoded values in the code that have
a real meaning and logic. \\
\newline
These values are likely to change in the future and probably need an
explanation or a comment to understand what they really are.
The code is less readable because its intent is not clear and the
maintenance becomes harder because every location where the value
is hardcoded must be modified. \\
A good practice is first to extract these values to variables or
constants and, if the value is very dynamic, externalize the
parameterization in a config file so it's easier to change.

\subsubsection{Value Objects}
Value Objects

\subsubsection{Fail Fast}
Fail Fast principle prevents the application from continuing a process if
it's likely to fail in the next steps. \\
\newline
This principle is usually implemented using a defensive code, that checks
the method parameters and ensure that every value, variable, service etc.
are available and consistent before continuing the process.
If some method parameters or fields are null for example, then any
further method call will necessarily fail. \\
\newline
At first glance, it doesn't matter if it fails now or later, in the end
it will always fail no matter what.
However the process may have several side effect operations and the null
parameter may be used only between two operations. \\
This means that the first operation is made even tough we already know
that we cannot reach the second operation, because the code will fail
with a null pointer exception.
If rollbacks are not correctly handled, then the application enters into
an inconsistent state and things get much worse. \\
\newline
Beside this inconsistency, this principle is also very helpful during
the development phase, because instead of hiding potential bugs, it
immediately notifies the programmer that something looks wrong. \\
One could argue that the robustness of the application is getting
weaker, especially on the client side, where the application may crash
if unexpected failures are not well handled.
Extensive use of this principle must be used with caution and
appropriated controls and failure handling must be added.

\subsubsection{Null Pointers}
%https://martinfowler.com/eaaCatalog/specialCase.html
%https://medium.com/@hinchman_amanda/null-pointer-references-the
%-billion-dollar-mistake-1e616534d485
%https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained
Sir C. A. R. Hoare, the null pointer creator, said the following.
\begin{quotation}
    I call it my billion-dollar mistake.
\end{quotation}
Null pointer is one of the most painful features in Object Oriented
Programming.
Missing value, business case not handled, unlikely state \ldots There are
a lot situations where we don't really know what to do or return.
The easy solution is therefore to return null and see what happens. \\
We talked about the Fail Fast principle earlier, usually applications
that use null values don't fail fast, otherwise they would either
stop using null or stop failing fast. \\
Obviously the first solution is better and we are going to present some
alternatives to null and some situations where null is viable. \\
\newline
The distinction between, a missing value because of the
programmer's mistake, and a real missing value because of business logic,
must be clear and unambiguous. \\
Null pointers are completely ambiguous because there's no guarantee that
the returned null pointer is actually representing a real missing value.
Maybe the programmer forgot to fill a particular field of an object
or used the wrong key when querying a HashMap or even have not
implemented this case and is returning null by default.
\\
\newline
Optional is a common type across programming languages and is now widely
used in standard APIs.
An Optional is a very simple object, that either contains a value or
is empty.
It has methods to tell whether it's empty or not and a getter (and some
utility methods). \\
The idea of optional is first to hide and encapsulate the null value
from the application's code.
Second, the programmer now has explicitly said that the method may not
return a result.
Where before the programmer could forget to think of checking for null
value, he is now aware that the returned value can be missing.
He is probably going to look why in the documentation and eventually
will implement a special case to handle it.
In addition, if a null pointer is returned, then there's no doubt that
it's a mistake. \\
Unfortunately sometimes, we can't really represent an optional value
with the Optional type.
For example in databases, it's frequent to have null pointers because
it occupies less disk space and it's faster. \\
It's also okay to use null in small private local context, to keep a simpler
code.\\
\newline
Another alternative is to use the Null Object Pattern.
This pattern uses a real object or value to represent a special or
missing value. \\
For example, an object Task could have the states PENDING, STARTED
and FINISHED .
When the task is submitted to the executor, the state is PENDING,
when the executor actually executes it, it turns to STARTED and when
it's done, it's FINISHED. \\
But when we create the Task, there is no current state, so we could use
null to represent the missing state.
Or we could introduce a new state, that indicates that there is currently
no state, NONE. \\
Now, when we want to see the current state of the task, we are
manipulating real values instead of a set of values and null pointers. \\
We also know that if the state is null, then it's because there was
a problem during the initialization of the Task. \\
Sometimes, it's hard to define a value for every possible case.
Dates are a nice example, it would be awkward to replace a missing date
by default value. \\
\newline
These two techniques are very helpful and tends to improve both the
readability and the design of the code.
The code is self describing and now manipulates as much as possible
real values instead of ambiguous null pointer.

\subsubsection{Side Effect}
Side Effect

\subsubsection{Immutability}
Immutability

\subsubsection{CQS}
%https://martinfowler.com/bliki/CommandQuerySeparation.html
%https://martinfowler.com/bliki/ObservableState.html
Command and Query Separation tries to separate operations that have
side effects and the ones that don't. \\
\newline
A Command is a method that only changes the state of the system and
returns void.
Not returning a value necessarily means that the method is doing
something elsewhere and therefore have side effects.
Further queries will be affected by this command call and their results
may vary.
This clarifies the intent of the method and its impact on the
application's state. \\
\newline
A Query is a method that returns a value and don't modify the
Observable State of the object.
This means that a query call will never affect or change the result of
the next queries on the same object, this is why we use the term of
Observable State.
Sometimes there are internal states that can be modified by queries but
they won't change the result of future queries.
One example is lazy loading, the first query call will have a side effect
but won't actually impact the returned value. \\
\newline
Pure CQS implementation is not very common and sometimes hard to achieve.
For example, we want to persist a JPA Entity that has auto generated ID.
When we call the persist method, we may need to return the persisted
object to retrieve the generated ID.
There are a lot of situations where it's more handy to directly return a
value after executing a command, this is why a full CQS application is
not necessarily ideal. \\
However, it's a nice principle to have in mind, because it helps to
identifies what really changes the application's state and what is only
retrieving information from it.
Having less side effects in the code code is usually a great choice.
