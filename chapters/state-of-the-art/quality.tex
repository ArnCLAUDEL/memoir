\section{Quality}\label{sec:quality}
We've talked about Software Craftsmanship and Extreme Programming,
one is a culture, the other is a methodology but both focus on Quality.
\\
This chapter will first present the metrics given by the analysis
tool Sonar and how we can use it during the refactoring phase.
Then we'll present a bunch of principles and design rules that
are used to improve the code quality and ease the maintenance.

\subsection{Sonar}\label{subsec:sonar}
%https://docs.sonarqube.org/latest/user-guide/issues/
%https://docs.sonarqube.org/latest/user-guide/concepts/
Sonar is a static code analysis tool, this means that it inspects
directly the source code and try to find some potential bugs, security
holes, duplicated code and code smells.
It is based on a huge repository of rules and common good practices.
Each rule comes with a description and good/bad examples. \\
After the analysis, Sonar gives a global grade (A, B, C etc.) and
publishes a detailed report with every broken rules.
In a CI platform, sonar analysis must be performed for every commit and
developers must keep an eye on the report. \\
\newline
Any broken rule during the analysis will create an issue in the report.
There are three types of issues :

\begin{description}
    \item[Bug :]
    An issue that represents something wrong in the code.
    If this has not broken yet, it will, and probably at the worst
    possible moment.
    This needs to be fixed.
    Yesterday.
    \item[Vulnerabilty :]
    A security-related issue which represents a backdoor for attackers.
    \item[Code Smell :]
    A maintainability-related issue in the code.
    Leaving it as-is means that at best maintainers will have a harder
    time than they should making changes to the code.
    At worst, they'll be so confused by the state of the code that
    they'll introduce additional errors as they make changes.
\end{description}

There are 5 levels of severity :

\begin{description}
    \item[BLOCKER :]
Bug with a high probability to impact the behavior of the application
in production: memory leak, unclosed JDBC connection, ....
The code MUST be immediately fixed.
    \item[CRITICAL :]
Either a bug with a low probability to impact the behavior of the
application in production or an issue which represents a
security flaw: empty catch block, SQL injection, \ldots
The code MUST be immediately reviewed.
    \item[MAJOR :]
Quality flaw which can highly impact the developer productivity:
uncovered piece of code, duplicated blocks, unused parameters,
    \ldots
    \item[MINOR :]
Quality flaw which can slightly impact the developer productivity:
lines should not be too long, "switch" statements should have at
least 3 cases, \ldots
    \item[INFO :]
Neither a bug nor a quality flaw, just a finding.
\end{description}

We are not going to detail deeply Sonar rules, there're too many of them,
this is actually why Sonar exists.
Programmers are humans and they can easily leave an unused variable, an
opened resource, forget to check for a likely null value or add an if
statement with a condition that is always false. \\
Sonar is a great companion that integrates perfectly with IDEs and will
necessarily teach something new to anyone using it.

\subsection{Principles and Design}\label{subsec:principles}

\subsubsection{Design Patterns}
Design Patterns

\subsubsection{SOLID}
SOLID

\subsubsection{KISS}
Keep It Simple Stupid is a \textit{simple} principle that encourages to
always try the simplest approach to solve a problem. \\
\newline
It's very easy to over engineer a solution to a problem, because we want
to cover all the possible cases or we want to add some extra
features that may be useful later.
This over engineering badly affects the maintainability of the code base
because the feature is overwhelmed by an unnecessary complex code. \\
\newline
KISS principle is often used in TDD because each step is a small
problem that solves a bigger complex problem.
In the Red, Green, Refactor cycle, during the Red phase, we must write
the simplest code to pass the test, this is exactly what KISS is about.
\\
\newline
One could argue that the simplest solution is not always the best one.
Sometimes it's nice to add some extra code to handle failure cases, add
defensive code for method parameters etc. \\
It depends on the context, for example a small private method, can make
legit assumptions and could omit to check null values when using
local field.
However a public method inherited from an interface should check for the
correctness of the received parameters.

\subsubsection{DRY}
Don't Repeat Yourself is a principle against code duplication and in
favour of reusable items in general. \\
\newline
Duplicated values and logic mean O(n) complexity when a change is needed
instead of O(1), if it was written in a single place.
Maintenance then becomes a nightmare and in the worst case, some lines of
code are omitted when refactoring, leading to inconsistent logic in the
application. \\
\newline
This principle is therefore vital for business logic but also relevant
for technical and utility features.
There're plenty of libraries that implements common algorithms, file
manipulation, serialization etc.
So it's usually a bad idea to try to reimplement locally something that
have been better done and is used by the whole community. \\
\newline
DRY is also a global principle and can be applied at a much higher level.
More and more production-ready frameworks or services only requires
the business code and can be immediately deployed.
Companies also try to reduce the time to market by creating starter kit,
reusing CI platform and cloud providers.

\subsubsection{Behaviour Parametrization}
Behaviour Parametrization is included in the DRY principle and is very
common in Functional Programming. \\
\newline
In traditional code, if we want to filter elements of a list of String
for example, we would write a for loop and write our condition inside.
Every element that matches the condition are then added to a previously
created list. \\
This works perfectly, but if tomorrow we want to add the same feature,
but with a slightly different condition.
We must rewrite the for loop, recreate a list and filter our elements.
We've just written Boilerplate code, that is duplicated lines of code
that are almost identical. \\
\newline
Behaviour Parametrization exactly solves that problem by externalizing
the behaviour (in our example, the filter condition) and reusing the
common code (the for loop and list creation). \\
There are well known Collection's methods such as map, filter or reduce
that takes behaviour as parameter.
Some cloud providers also provides ready-to-use web services,
where you simply add your business code and it's automatically managed
and deployed.

\subsubsection{Clean Code}
Clean Code is a subset of rules and principles that helps to make and
keep a clean codebase and we are going to list the main ideas. \\
\newline
A Clean code is literally \textit{clean}, it should be
pleasant to read and it's easy to understand what's going on.
This is where DRY and KISS principles, that we mentioned earlier,
are very important to have a cleaner code.
Class, method and variable names should be meaningful and self
describing, so there's no need of extra comment to explain the logic.
The code across the project always follows the same standards, has the
same format and is well indented. \\
\newline
Nested blocks (for/if/else \ldots) shouldn't go to deep
because the deeper, the harder it is to understand the logic.
For example, error handling code (usually try/catch blocks) should be
externalized and located in a dedicated method.
This reduces the pollution and the noise around the main feature. \\
There is an interesting metric called Cyclomatic Complexity that tries to
measure the level of visual complexity of code.
Nested statements, as well as switch statements, are one of the worst
elements and add a lot of complexity.
Usually, when there are several nested lines of code, it is better to
extract them to a private method.

\subsubsection{Magic Numbers}
Magic Numbers represent all the hardcoded values in the code that have
a real meaning and logic. \\
\newline
These values are likely to change in the future and probably need an
explanation or a comment to understand what they really are.
The code is less readable because its intent is not clear and the
maintenance becomes harder because every location where the value
is hardcoded must be modified. \\
A good practice is first to extract these values to variables or
constants and, if the value is very dynamic, externalize the
parameterization in a config file so it's easier to change.

\subsubsection{Value Objects}
Value Objects

\subsubsection{Null Pointers}
%https://martinfowler.com/eaaCatalog/specialCase.html
%https://medium.com/@hinchman_amanda/null-pointer-references-the
%-billion-dollar-mistake-1e616534d485
%https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained
Sir C. A. R. Hoare, the null pointer creator, said the following.
\begin{quotation}
    I call it my billion-dollar mistake.
\end{quotation}
%TODO add details

\subsubsection{Side Effect}
Side Effect

\subsubsection{Fail Fast}
Fail Fast principle prevents the application from continuing a process if
it's likely to fail in the next steps. \\
\newline
This principle is usually implemented using a defensive code, that checks
the method parameter and ensure that every value, variable, service etc.
are available and consistent before continuing the process.
If some method parameters or field are null, then any method call on
them will necessarily fail. \\
At first glance, it doesn't matter if it fails now or later, it will
always fail in the end.
%TODO talk about side effects that occurs before the failure

\subsubsection{Immutability}
Immutability

\subsubsection{CQS}
%https://martinfowler.com/bliki/CommandQuerySeparation.html
%https://martinfowler.com/bliki/ObservableState.html
Command and Query Separation tries to separate operations that have
side effect and the ones that don't. \\
\newline
A Command is a method that only changes the state of the system and
return void.
Not returning a value necessarily means that the method is doing
something elsewhere and therefore have side effects.
This clarifies the intent of the method and its impact on the
application's state. \\
\newline
A Query is a method that returns a value and don't modify the
Observable State of the object.
This means that a query call will never affect or change the result of
the next queries on the same object, this is why we use the term of
Observable State.
Sometimes there are internal states that don't change the result, like
lazy loading or constant value caches. \\
\newline
Pure CQS implementation is not very common and sometimes hard to achieve.
For example, we want to persist a JPA Entity that has auto generated ID.
When we call the persist method, we may need to return the persisted
object to retrieve the generated ID.
There are a lot of situations where it's more handy to directly return a
value after executing a command, this is why a full CQS application is
not necessarily ideal. \\
However, it's a nice principle to have in mind, because it helps to
identifies what really changes the state and what is only retrieving
information from it.
Having less side effects in the code code is usually a great choice.
