\section{Behavior Driven Development}\label{sec:bdd}
%http://kilianwebservice.de:8080/documents/20195/62637/BDD_in_Action.pdf/3a6a2aef-5bf5-4ccd-a33d-e153d1a9edb3
%https://dannorth.net/introducing-bdd/

This section will introduce the notion of \textit{Behaviour Driven
Development}, with its key concepts, benefits and limits or pitfalls.
This section is mostly based on the book \textit{BDD in Action}.

\subsection{Key concepts}\label{subsec:bdd-key-concepts}

\subsubsection{A new version of TDD}
We already mentioned TDD while presenting Extreme Programming, this method
basically consist of writing a failing test before writing any production code.
Well few years after TDD, Dan North wrote an article to introduce BDD\@.

Traditional unit tests written with TDD are very low-level and focus
primarily on a class or method.
They were meant to drive the low-level implementation and therefore were very
tied to it.
Dan talked about a problem he used to encounter when he was teaching TDD in
a teams.
People were a bit lost with TDD, on how to start, how to name its tests or how
even to know when there is enough tests for this feature.

He decided to introduce some new practices and conventions to focus on the
behaviour when writing test, instead of focusing on the implementation itself.
This means that a test should simply describe what the method \textit{should}
do instead of \textit{how}.

\subsubsection{Focus on valuable feature}
In traditional methods such as waterfall, the integration team starts by
understanding all the customer needs and then designs a solution that should
fulfill the needs.

When the design is done, the developers will just have to implement a bunch
of requirements, which when developed will shape the features of the software.
The problem is that the end user is not really involved in the process and
nothing takes into account what the end user might expect when using the
application.

In addition of making the needs harder to understand, this can cause the
development of completely useless features, that were in the design model but
won't be used at all by the users.
BDD tries to avoid this by bringing the end users at the center of the
discussion.

The idea is to discuss about the expected behaviour for an end user and
progressively build the features by only adding the business value.
This will also help the developers to really understand what they're
implementing and see how this feature will make the current software more
valuable.

\subsubsection{Work together}
BDD is a highly collaborative practice, between every member of the project,
whether they are end users, clients, analysts, developers etc.
BDD aims to avoid having the one-way communication between the analysts and
developers.
In a traditional approach, they would only provide the specifications to
understand the needs and the business meaning of the features.

When only the specifications are used to implement a solution, first the
result will only depend on the good understanding of the needs by the
developers.
But the solution can potentially miss the mark and deliver a solution that
fulfills the specifications but doesn't fit at all to the end users.

In order to solve this kind of issue, a BDD project involves everyone and
especially the end users in the process.
This produces valuables discussions where each person bring its skills and
knowledge, to design the best solution.
Now they'll share the same vision of the business domain and will also feel more
engaged in the project.

\subsubsection{Embrace uncertainty}
BDD, as any agile methodology does, assumes that the needs and requirements
will change one day or later.
Therefore, BDD opts to have very early feedback from the stakeholders and end
users on the developed features.

As these features are defined by their expected behaviour, it's easier to
show and to discuss about it.
Clients can therefore easily formulate their comment, even propose a new
behaviour if it's not what they were expecting.
The idea is to have this feedback as soon as possible, so the team knows if
they're going in the right direction instead of waiting for the end of the
development phase and eventually start all over again.

This approach may also help in prioritizing the features to implement, as the
team will always have then up-to-date state of mind of the client and end
users.

\subsubsection{Features with concrete examples}
A BDD project design its features by defining their expected behaviour.
This expected behaviour is represented by scenarios and examples.
This examples-oriented approach is at the core of BDD and is based on
the concept of working together.

Features are described and formalized during the discussions between the
clients and the integration team.
To better understand each others, they must use the same vocabulary and have
the same vision of the project.
Examples are a very effective way of clearly communicating without being
ambiguous when discussing about the requirements.

Examples are also great for requirements exploration, where the analysts
would ask a lot of questions to clarify certain points, define some special
scenarios and use cases.
Any clarification questions like 'What if this happens ?' or 'How should the
application behave when the user inputs this ?' will produce new examples and
maybe new features or scenarios.

\subsubsection{Executable specifications}
As BDD features are defined using examples, some great tools exist to turn
them to executable specifications.
The idea is to use these examples as acceptance criteria, that will determine
whether the feature is implemented or not.

Each step in the scenario will be programmatically implemented and do what
the action describes.
These scenarios can then be automated and will turn the specification
examples to automated acceptance tests.

These executable specifications can then serves as guideline for the
developers, as it will objectively tells when the feature is done.
In addition, once the test passes, it automatically turns into a non regression
test.

\subsubsection{Living documentation}
The examples used to define a feature, when turned to executable
specifications, will in the end serve as documentation.
Every scenario represent a possible path in the application, therefore every
working scenario can be used as documentation support.

A documentation made of examples can be very useful to easily understand
what is possible to do in the application.
This is very great for newcomers or maintainers, as they can easily explore
and understand the application, with this up-to-date documentation.

It's also easier to evolve the application, because you simply need to change
the scenario and its examples to define the new behaviour.
As they are executable specifications, the team can immediately see what's
needed to implement the new features.

\subsection{Benefits}\label{subsec:benefits}

\subsubsection{Reduction of cost}
BDD helps in reducing the overall cost of development.
When focusing on behaviour, the team will only implement what is necessary to
make the features working.
This completely remove the risk of implementing a useless feature or service
just because it was specified in the list of requirements.

Having an early feedback is also very helpful.
Instead of waiting the end of the development process to note the gap
between the delivered solution and the actual needs, the team will be able to
quickly know when they are drifting away.

\subsubsection{Easier and safer changes}
As mentioned when presenting the concept of executable specifications, a BDD
project will be easier to maintain and evolve thanks its the scenarios.
When a change is made, the automated tests will be executed and the team will
instantly know if there is any regression.

New scenarios can also pass immediately after being written, because the
application already handles this specific example, therefore there is no need
to implement something.
This is a big benefit from any TDD-like method.

\subsubsection{Automated tests}
BDD tests are almost always automated, therefore the team will have a
comprehensive set of acceptance and non regression tests at disposition, which
will greatly help for future releases.

\subsection{Limits}\label{subsec:bdd-limits}

Communication is at the core of BDD, therefore project with poor
communication between clients, analysts and developers are likely to not
benefit from BDD\@.

Project organized in silo are therefore not very well suited for BDD, nor
agility in general.
When the clients, analysts, developers and testers aren't in the same place
nor working together, they won't communicate enough about the business domain.
There won't be a shared vocabulary of the business domain and this will lead
to very low-quality scenarios.

BDD can be very costly with low-quality scenario.
Brittle, unclear or too precise scenarios are very hard to maintain because
they'll constantly require some modification to pass and the team is likely
to be annoyed by these scenarios.
