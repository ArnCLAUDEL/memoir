\section{Extreme Programming}\label{sec:extreme-programming}
%www.altexsoft.com/blog/business/extreme
%-programming-values-principles-and-practices/
%www.extremeprogramming.org
Extreme Programming (XP) is a well known agile methodology, created by
Kent Beck.
The first projects using XP started in 1996.
We are not going to deeply present the methodology but at least we are
going to state the main values and detail the features that could be
relevant to our solution.

\begin{description}
    \item[Simplicity :] Minimum effort for maximum value. \\
    The idea is to always turn complex situations in small simple steps,
    making them easy to implement and reducing the cost of failure.
    \item[Commmunication :] Daily face to face between every team member. \\
    Everyone on a team works jointly at every stage of the project.
    \item[Feedback :] Constant and Early feedback on the product. \\
    Frequent demo of the product in order to always have a software that
    matches the current requirements.
    \item[Respect :] Simple respect between project members. \\
    They all have the same goal of delivering the greatest project.
    \item[Courage :] Objectivity and Transparency at any time. \\
    Never hide potential failures, lie on project's advancement. \\
    We don't document excuses for failure because we plan to succeed.
\end{description}

\subsection{Test Driven Development}
\label{subsec:test-driven-development}
%https://medium.freecodecamp.org/test-driven-development-what-it-is
%-and-what-it-is-not-41fa6bca02a2
Test Driven Development (TDD) is a very interesting methodology for
writing tests.
Uncle Bob describes TDD with 3 rules :

\begin{quote}
    \begin{itemize}
        \item You are not allowed to write any production code unless it is to
        make a failing unit test pass.
        \item You are not allowed to write any more of a unit test than is
        sufficient to fail;
        and compilation failures are failures.
        \item You are not allowed to write any more production code than is
        sufficient
        to pass the one failing unit test.
    \end{itemize}
\end{quote}

These rules are very restrictive and they don't look very natural
compared to what we use to do.
There is a method that allow us to easily follow these rules, the
Red Green Refactor cycle.

\subsubsection{The Red Light}
First you need to write a failing test and see the red light.
But your test cannot even run, it doesn't compile because there is
actually no production code.
So you create your class with empty methods in order to be able to run
the test. \\
And now you have a red light.

\subsubsection{The Green Light}
This red light must disappear as soon as possible, so you have to write
the minimum amount of code required to turn the light green.
The minimum means that you are rushing to the green light, duplicated
code, hardcoded values or worst if you want, the code simply need to
work. \\
Now you've reached the green light.

\subsubsection{The Refactor Phase}
Here you have a terrible (but working) code.
All you have to do now is refactoring, eliminating duplication,
extracting methods, variables, constants etc.
You don't have the fear anymore of breaking the feature while
refactoring, your fresh test will cover you for this. \\
Now you have a clean and working code, you can write a new failing test
and repeat the process again.

\subsubsection{Step By Step}
This approach is very incremental, we only go with very small steps :
baby steps.
Breaking a complex problem in smaller simple problems helps to tackle it
and is a good practice in general.

Usually, the feature is split into a list of small cases and the
programmer starts with the simplest case.
When the light is green, he looks for the next simplest case and
continues until he realizes that there's a lot of duplicated code.

After that, he can make an effective refactor and abstracts his code to
make it more generic and handle the rest of the 'simple' cases.
He can now write a test for a more complex case and do the same thing
again.

\subsubsection{Conclusion}
TDD allows programmers to be confident with their tests because they
describe how the production code should behave.
The production code was written only to make these tests pass, so if
one test fails few days later, it's because something has been broken
somewhere and there is a real regression.

Finally, a quick mention of the two types of TDD: Detroit (Classicist)
vs London (Mockist).
The London style tends to overuse mocks (that will be detailed later)
where Detroit style tries to avoid them. \\
Detroit style is a black-box approach and doesn't want to set up the
Collaborators of the System Under Test (SUT).
Where London style is more like a white box and makes a clear distinction
between the SUT and its Collaborators.
The SUT is completely isolated from its Collaborators, so the test will
always behave exactly the same, even if a collaborator has been modified.

\subsection{Pair Programming}\label{subsec:pair-programming}
%http://www.extremeprogramming.org/rules.html
A rule of XP says :
\begin{quotation}
    All production code is pair programmed.
\end{quotation}
Pair Programming is a methodology that consists in having 2 programmers
working on the same work station.
The one with the keyboard is the Driver, the other one is the Navigator.
The Driver writes the code while the Navigator is watching for potential
mistakes, bugs, thinking of a better design, writing the next TDD steps
etc.

The communication while pairing is very important and must be almost
continuous.
Programmers must help each others, tell what they are doing, share their
mind and knowledge in order to write the better code.

When a programmer faces a problem alone, he could get stuck for hours,
even when the solution is simple.
He cannot find it because he keeps the same (wrong) point of view.
Sometimes, explaining the problem to another person is enough to find
the solution and if not, maybe the other person already tackled this
issue few days go and will explain the trick.

Pairing can reduce the frustration of getting stuck on small technical
problems because the knowledge and the experience of both programmers
are shared and they can focus on the complex problems.

Beside increasing the quality of code and reducing the new bugs, pairing
is also very interesting in the management of your team.
It's now easy for a newcomer to become part of the team, see how they
work and adopt the same standards.
Pairs can be changed every week or month, so everyone is working with
everyone and you share all the same standards and practices.

There is what we call the Bus Factor, it represents how many people your
project requires to be able to continue.
For example, if every programmer works alone on their own features and
then one day, there is a production bug on a feature.
If the author is not in the team anymore, then nobody knows how the
feature is implemented and even less how to fix it.

As pairing shares the knowledge across the team, you have at least two
persons that worked on the feature.
The pair could also have changed while the feature was in progress, so you
have even more programmers that worked on it.

We covered the main ideas of Pair Programming and we showed what great
things it can do for a project and its team.
However, Pair Programming is clearly not suited for everyone.
Sometimes, it just doesn't work, people can feel uncomfortable while
pairing, one may always want the keyboard or remains completely
silent and there's no communication between the programmers.
Juniors could also be impressed by a senior and therefore won't dare to
propose a new approach or design.

Clients and managers can also be reluctant to this and claims that
pairing cuts in half the productivity and doubles the cost.
It can be true, especially when the team members are not comfortable with
pairing and there is a bad communication.

Finally, we can mention that Pair Programming is not only two persons on
one work station.
It's frequent to pair with a remote programmer and share your screen.
It's actually very interesting with a remote team, because it brings the
important direct communication between team members that you don't
usually have in remote.

Pairing can be also be done with one work station but two mouses and
keyboards.
Some pairs also have two work stations but share their screens.
There are a lot of configurations and the best one is always the one
chosen and preferred by the team that will use it.

\subsection{Continuous Integration}\label{subsec:continuous-integration}
%https://martinfowler.com/articles/continuousIntegration.html
%http://www.extremeprogramming.org/rules/integrateoften.html
In this last section, we'll talk about Continuous Integration (CI).
CI is now a standard and helps to reduce the harm of integration phase
after several days or weeks of work.

\begin{quotation}
    Developers should be integrating and commiting code into the code
    repository every few hours, when ever possible.
    In any case never hold onto changes for more than a day.
\end{quotation}

Local work doesn't take into account new changes and your code could rely
on obsolete features.
You're also likely to recreate a utility feature that already exists and
could have been reused.
Generally, the longer your code stays on your local machine, the harder
to integrate with the rest of the application.

This is were the CI platform helps team by building and testing
the application as often as possible.
A periodic call is made to the repository to see if there are new
commits.
If so, then the platform makes a complete checkout of the source code.
The code is then compiled, packaged and tested.
A report is produced and displayed in a dashboard accessible by the
whole team.

CI does not reduce the number of bugs but it helps to detect them as soon
as possible.
It will be easier to fix a bug detected by the CI because you know when
the last build passed and can see the new committed code that failed
the current build.
When a build fails, it's because something went wrong and it must be
quickly fixed, else it will block other programmers from integrating
their features.

CI is very tied to the notion of Collective Ownership, which
encourages every programmer to contribute to the project, fix bugs,
improve a feature, its design etc.
CI ensure that your contribution doesn't break other's work.

% TODO a bit more the notion of Collective Ownership