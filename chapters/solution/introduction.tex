\section{Introduction}\label{sec:introduction}

This introduction will cover three points of the state of the art. \\
First, it will list the problems of the waterfall methodology / v-model
that this solution is going to address. \\
Then it will explain why we don't simply adopt the presented agile methods, such
as XP or the BDD approach, instead of keeping the waterfall or v-model. \\
Finally, it will quickly show how we are going to use some principles and
methods of these agile methods, to be able to inject them in our new process.

\subsection{Problems to address}\label{subsec:problems-to-address}

This part will list the problems when using the waterfall methodology or the
v-model.

\subsubsection{Too many sources of information}
As said in the state of the art, these two methodologies are very
document-oriented and many documents are produced throughout the project
lifecycle.
Documents such as requirements, specifications (technical or non-technical),
test strategy, test cases, test execution reports etc.
are all source of information.

These documents are all related to each other by \textit{weak links}.
A \textit{weak link} represent a link between two or more components that
only (or heavily) relies on human effort to keep them coherent and correlated.
Human effort is known to be unreliable and error-prone.

This is one of the technology murphy's laws:
% http://www.murphys-laws.com/murphy/murphy-technology.html
\begin{quote}
    Computers are unreliable, but humans are even more unreliable.
    Any system which depends on human reliability is unreliable.
\end{quote}

This solution will try to reduce the number of links, while increasing their
strength of the links to ease their maintenance and use them to drive the
workflow.

\subsubsection{Several interpretations of the specification}
In the traditional workflow, the implementation phase starts after the
specification and test strategy phases.
Meanwhile, the testers "implements" the test strategy by writing the
test cases for the specification.
Once the test cases are ready, they are executed to validate that the code
correctly implements the specification.

The problem is that both the dev and test team are individually interpreting
the specification and will write the code and test cases with their own
mindset and understanding of the feature.

The specification may contain some abstract or unclear sections, that were
obvious to the writer but are obscure for a developer.
It can also contain some small typo or copy paste errors.
The developer may miss it or decide to strictly follow the specification,
where the tester will catch the error and fix it in its test case.

These both interpretations will only be confronted during the test
execution phase.
This late junction is likely to highlight a lot of divergences between the
expected behaviour and the actual one.

\subsubsection{Behavior vs Specification}
In a document-oriented approach, when the specification and the test strategy
are written, the implementation phase can start.
The specification is split into sub tasks that are assigned to the developers.

The developer will read the specification and then write the code implement
it, create new classes, methods etc.
In the v-model he will also write some unit and integration tests to validate
its low level code and all tests pass, the specification should be correctly
implemented.

The problem is that the expected behaviour is only tested after the
implementation of the specification.
When the functional test pass, we can't really be sure if it passes thanks to
the new code or if it was already supported in the application.
Testing the behaviour after means that we don't really know how it was
before and increase the risk of adding redundant or unreachable code.

\subsubsection{Automation as an optional step}
In the waterfall methodology and v-model, there is no clear mention of test
automation.
This makes automation an optional step, that can be easily skipped when the
project is tight on deadlines.

Even when automation is set up, it usually remains as a side project, with
only a portion of the complete test case set.
Newly created test are not automatically added to the automated set and the
project is likely to become obsolete and abandoned.

The problem is that manual testing makes test less replayable and costly over
time.
As we said earlier, anything that relies on human reliability is unreliable.
When test are written for humans and executed by humans, minor errors like
typo, copy past or unclear statement can easily be caught and
understood by a human.

When a test is meant to be executed by a machine, it must be completely clear
and well defined.
This can sounds like a disadvantage, but this makes the test formal and
rigorous.
It will be easy to execute again and there is no room for interpretation or
tacit knowledge.

\subsubsection{Lack of confidence}

% TODO because there's no automated tests
% TODO it's working, don't touch it
% TODO documents are usually outdated
% TODO weak links between documents make them unreliable

\subsection{Why not agility ?}\label{subsec:whby-not-agility}

% TODO refactor the intro to better fit this part in the solution

We now have an overview of the current methods and tools to improve the
quality of our projects.
We've seen the traditional workflow in both waterfall and V-model, and their
limitations.
We've also covered some agile methodologies that get rid of certain of these
problems.

An easy solution could be simply to abandon the waterfall or V-model and become
agile.
However agile, like any other method, is not a silver bullet and sometimes,
switching from waterfall to agile is not necessarily the solution.
This section is going to cover some of the reasons to stay in with the
waterfall methodology.

\subsubsection{Team members}
In a team where members have been working in waterfall for decades, switching
to a new methodology can be tricky.
Whether it's because of the fear of change or reticence against the
trending agility methodology, people may be reluctant to do the transition.

When people are almost forced to change their habits, the full transition
almost never occurs and the team keeps some of its old habits.
In this situation, it's likely to be worst than if the team stayed with its
traditional methodology
This is the case for team members but it's even more true for clients.

\subsubsection{Clear requirements}
One of the main statements of agility is that the requirements are usually
unclear and likely to change.
Therefore in an agile context, the analysts will take the time to talk with
the client to understand its needs.
A real work of requirements exploration is made, to help the client
formalize its desires.

However, this kind of exploration is not always needed to define the
requirements.
For example, public services or financial agencies etc.
are not going to invent or discuss their needs with an analyst.
Tax rates, invoices format or government rules are already clearly defined.
The integration team just have to retrieve all these formalized business rules.

\subsubsection{Project context}
Some project contexts may also not be well suited for agile and its iterative
cycle.
A client may not want frequent releases of its software, but rather few
releases in a year.
Whether it can be because software updates are expensive, which is common in
legacy systems, or simply because there's not that much requirement changes.

The client may also not have the time or the resources to be really involved
in the project.
Agile project take the time to make a lot of demo, get early feedback from
the client etc.
which is a great approach.
But when the client only have a small one-shot application, with predefined
user interface and features, then agility is not well suited.
Especially when the integration team works in remote, there's usually not a
lot of communication with the client during the development process.

The importance of documentation can also matter.
In an agile context, we tend to get rid of the documentation, for relevant
reasons.
Whereas in waterfall, documentation is contractual and therefore part of the
delivery content.
Some clients may feel more comfortable when they have this documentation,
with all the supports that helped in making it.

\subsection{Use of the State of the art}\label{subsec:use-of-the-state-of-the-art}

\subsubsection{V-Model}
% TODO stick with the document-oriented approach
% TODO the process will be different

\subsubsection{Extreme Programming}
% TODO use some principles from XP like TDD, PP and CI

\subsubsection{Behavior Driven Development}
% TODO why can't BDD be directly applied ?
% TODO cherry pick BDD