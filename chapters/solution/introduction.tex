\section{Introduction}\label{sec:introduction}

This introduction will cover three points of the state of the art. \\
First, it will list the problems of the waterfall methodology / v-model
that this solution is going to address. \\
Then it will explain why we don't simply adopt the presented agile methods, such
as XP or the BDD approach, instead of keeping the waterfall or v-model. \\
Finally, it will quickly show how we are going to use some principles and
methods of these agile methods, to be able to inject them in our new process.

\subsection{Problems to address}\label{subsec:problems-to-address}

This part will list the problems when using the waterfall methodology or the
v-model.

\subsubsection{Too many sources of information}
As said in the state of the art, these two methodologies are very
document-oriented and many documents are produced throughout the project
lifecycle.
Documents such as requirements, specifications (technical or non-technical),
test strategy, test cases, test execution reports etc.
are all source of information.

These documents are all related to each other by \textit{weak links}.
A \textit{weak link} represent a link between two or more components that
only (or heavily) relies on human effort to keep them coherent and correlated.
Human effort is known to be unreliable and error-prone.

This is one of the technology murphy's laws:
% http://www.murphys-laws.com/murphy/murphy-technology.html
\begin{quote}
    Computers are unreliable, but humans are even more unreliable.
    Any system which depends on human reliability is unreliable.
\end{quote}

This solution will try to reduce the number of links, while increasing their
strength of the links to ease their maintenance and use them to drive the
workflow.

\subsubsection{Several interpretations of the specification}
In the traditional workflow, the implementation phase starts after the
specification and test strategy phases.
Meanwhile, the testers "implements" the test strategy by writing the
test cases for the specification.
Once the test cases are ready, they are executed to validate that the code
correctly implements the specification.

The problem is that both the dev and test team are individually interpreting
the specification and will write the code and test cases with their own
mindset and understanding of the feature.

The specification may contain some abstract or unclear sections, that were
obvious to the writer but are obscure for a developer.
It can also contain some small typo or copy paste errors.
The developer may miss it or decide to strictly follow the specification,
where the tester will catch the error and fix it in its test case.

These both interpretations will only be confronted during the test
execution phase.
This late junction is likely to highlight a lot of divergences between the
expected behaviour and the actual one.

\subsubsection{Behavior vs Specification}
In a document-oriented approach, when the specification and the test strategy
are written, the implementation phase can start.
The specification is split into sub tasks that are assigned to the developers.

The developer will read the specification and then write the code implement
it, create new classes, methods etc.
In the v-model he will also write some unit and integration tests to validate
its low level code and all tests pass, the specification should be correctly
implemented.

The problem is that the expected behaviour is only tested after the
implementation of the specification.
When the functional test pass, we can't really be sure if it passes thanks to
the new code or if it was already supported in the application.
Testing the behaviour after means that we don't really know how it was
before and increase the risk of adding redundant or unreachable code.

\subsubsection{Automation as an optional step}
In the waterfall methodology and v-model, there is no clear mention of test
automation.
This makes automation an optional step, that can be easily skipped when the
project is tight on deadlines.

Even when automation is set up, it usually remains as a side project, with
only a portion of the complete test case set.
Newly created test are not automatically added to the automated set and the
project is likely to become obsolete and abandoned.

The problem is that manual testing makes test less replayable and costly over
time.
As we said earlier, anything that relies on human reliability is unreliable.
When test are written for humans and executed by humans, minor errors like
typo, copy past or unclear statement can easily be caught and
understood by a human.

When a test is meant to be executed by a machine, it must be completely clear
and well defined.
This can sounds like a disadvantage, but this makes the test formal and
rigorous.
It will be easy to execute again and there is no room for interpretation or
tacit knowledge.

\subsubsection{Lack of confidence}
In traditional methodologies, when the document heavily relies on human
effort to stay coherent, when tests are manually executed or when the
specification are unclear and people are likely to interpret it differently,
the entire team is going to lack of confidence in what it does.

The project components are so brittle, that any action can potentially brake
something.
In this context, the team will try to reduce as most as possible any
modification of the existing base.
Therefore, things like code refactoring, feature improvement, code deletion
are forbidden, "just in case".

The documentation is also affected by this lack of confidence, especially after
several months and iterations.
For example, when someone is reading the documentation and see something
incoherent with the actual behavior of the application, it doesn't
necessarily mean that it's bug.
The document is likely to be outdated or the developer probably used some
extra information elsewhere to implement this feature.
Hence the documentation isn't trustful and we can't be sure that it actually
represents the current application.

\subsection{Why not agility ?}\label{subsec:whby-not-agility}

% TODO refactor the intro to better fit this part in the solution

We now have an overview of the current methods and tools to improve the
quality of our projects.
We've seen the traditional workflow in both waterfall and V-model, and their
limitations.
We've also covered some agile methodologies that get rid of certain of these
problems.

An easy solution could be simply to abandon the waterfall or V-model and become
agile.
However agile, like any other method, is not a silver bullet and sometimes,
switching from waterfall to agile is not necessarily the solution.
This section is going to cover some of the reasons to stay in with the
waterfall methodology.

\subsubsection{Team members}
In a team where members have been working in waterfall for decades, switching
to a new methodology can be tricky.
Whether it's because of the fear of change or reticence against the
trending agility methodology, people may be reluctant to do the transition.

When people are almost forced to change their habits, the full transition
almost never occurs and the team keeps some of its old habits.
In this situation, it's likely to be worst than if the team stayed with its
traditional methodology
This is the case for team members but it's even more true for clients.

\subsubsection{Clear requirements}
One of the main statements of agility is that the requirements are usually
unclear and likely to change.
Therefore in an agile context, the analysts will take the time to talk with
the client to understand its needs.
A real work of requirements exploration is made, to help the client
formalize its desires.

However, this kind of exploration is not always needed to define the
requirements.
For example, public services or financial agencies etc.
are not going to invent or discuss their needs with an analyst.
Tax rates, invoices format or government rules are already clearly defined.
The integration team just have to retrieve all these formalized business rules.

\subsubsection{Project context}
Some project contexts may also not be well suited for agile and its iterative
cycle.
A client may not want frequent releases of its software, but rather few
releases in a year.
Whether it can be because software updates are expensive, which is common in
legacy systems, or simply because there's not that much requirement changes.

The client may also not have the time or the resources to be really involved
in the project.
Agile project take the time to make a lot of demo, get early feedback from
the client etc.
which is a great approach.
But when the client only have a small one-shot application, with predefined
user interface and features, then agility is not well suited.
Especially when the integration team works in remote, there's usually not a
lot of communication with the client during the development process.

The importance of documentation can also matter.
In an agile context, we tend to get rid of the documentation, for relevant
reasons.
Whereas in waterfall, documentation is contractual and therefore part of the
delivery content.
Some clients may feel more comfortable when they have this documentation,
with all the supports that helped in making it.

\subsection{Use of the State of the art}\label{subsec:use-of-the-state-of-the-art}

In this part, we are going to quickly explain the use and possible adaptation
of the tools and methodologies covered during the state of the art.

\subsubsection{Waterfall}
The waterfall methodology is obviously going to be the base of our solution,
because we want to stick with the document-oriented approach.
The workflow itself is going to change and new phases will be added to it.
The design phases won't be really modified, as the solution is not aiming to
improve the conception and design principles of an application.

\subsubsection{V-Model}
The V-model is not going to be used as it is and there won't be any V shape
to the process.
The emphasis on the tests brought by the V-model however will be kept and
put at the forefront even more, by adding new test-related phases to the
workflow.

\subsubsection{Extreme Programming}
Extreme Programming is an agile methodology, and as previously mentioned,
this solution want to stay in a waterfall-like approach, so it can't be
simply applied directly to our workflow.
However, XP is mostly based on a simple set of rules.
Some of them are standalone and can be directly used in any project context.
Hence, the workflow of this solution will try to adopt some of these rules,
such as working in TDD, Pair Programming or Continuous Integration.

\subsubsection{Behavior Driven Development}
As the process of BDD is more suited for agile context, it currently hardly
fits in a waterfall or V-model context.
However this solution will make use  the principles and core concepts of the
BDD\@.
Therefore we'll modify the workflow by adding some new phases to be able to
use the behaviour approach and embrace the Acceptance Test Driven Development.
We're also going to use extensively the scenario test format with Cucumber.